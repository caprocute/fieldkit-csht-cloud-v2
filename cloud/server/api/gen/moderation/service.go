// Code generated by goa v3.2.4, DO NOT EDIT.
//
// moderation service
//
// Command:
// $ goa gen gitlab.com/fieldkit/cloud/server/api/design

package moderation

import (
	"context"

	moderationviews "gitlab.com/fieldkit/cloud/server/api/gen/moderation/views"
	goa "goa.design/goa/v3/pkg"
	"goa.design/goa/v3/security"
)

// Service is the moderation service interface.
type Service interface {
	// Add implements add.
	Add(context.Context, *ModerationAddPayload) (res *ModerationRequest, err error)
	// Cancel a moderation request
	Cancel(context.Context, *CancelPayload) (err error)
	// Check if user has reported a specific post
	CheckUserReport(context.Context, *CheckUserReportPayload) (res *CheckUserReportResult, err error)
	// Acknowledge a moderation request with action
	Acknowledge(context.Context, *AcknowledgePayload) (res *ModerationRequest, err error)
	// List moderation requests
	ListRequests(context.Context, *ListRequestsPayload) (res *ModerationRequests, err error)
	// Get content for moderation review
	GetContent(context.Context, *GetContentPayload) (res string, err error)
}

// Auther defines the authorization functions to be implemented by the service.
type Auther interface {
	// JWTAuth implements the authorization logic for the JWT security scheme.
	JWTAuth(ctx context.Context, token string, schema *security.JWTScheme) (context.Context, error)
}

// ServiceName is the name of the service as defined in the design. This is the
// same value that is set in the endpoint request contexts under the ServiceKey
// key.
const ServiceName = "moderation"

// MethodNames lists the service method names as defined in the design. These
// are the same values that are set in the endpoint request contexts under the
// MethodKey key.
var MethodNames = [6]string{"add", "cancel", "checkUserReport", "acknowledge", "listRequests", "getContent"}

// ModerationAddPayload is the payload type of the moderation service add
// method.
type ModerationAddPayload struct {
	Auth     *string
	PostID   int32
	PostType string
}

// ModerationRequest is the result type of the moderation service add method.
type ModerationRequest struct {
	ID                 int32
	PostID             int32
	PostType           string
	ReportedBy         int32
	ReportedByName     *string
	ReportedAt         string
	AcknowledgedBy     *int32
	AcknowledgedByUser *UserInfo
	AcknowledgedAt     *string
}

// CancelPayload is the payload type of the moderation service cancel method.
type CancelPayload struct {
	// JWT token
	Auth string
	// Post ID
	PostID int32
	// Post type
	PostType string
}

// CheckUserReportPayload is the payload type of the moderation service
// checkUserReport method.
type CheckUserReportPayload struct {
	// JWT token
	Auth string
	// Post ID
	PostID int32
	// Post type
	PostType string
}

// CheckUserReportResult is the result type of the moderation service
// checkUserReport method.
type CheckUserReportResult struct {
	HasReported bool
	CanWithdraw bool
}

// AcknowledgePayload is the payload type of the moderation service acknowledge
// method.
type AcknowledgePayload struct {
	// JWT token
	Auth string
	// Request ID
	ID int32
	// Action to take (delete/keep)
	Action string
}

// ListRequestsPayload is the payload type of the moderation service
// listRequests method.
type ListRequestsPayload struct {
	// JWT token
	Auth string
	// Page number
	Page int32
	// Page size
	PageSize int32
}

// ModerationRequests is the result type of the moderation service listRequests
// method.
type ModerationRequests struct {
	Requests   []*ModerationRequest
	TotalPages int
}

// GetContentPayload is the payload type of the moderation service getContent
// method.
type GetContentPayload struct {
	// JWT token
	Auth string
	// Type of post
	PostType string
	// ID of the post
	PostID int32
}

type UserInfo struct {
	Name string
}

// MakeUnauthorized builds a goa.ServiceError from an error.
func MakeUnauthorized(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "unauthorized",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeForbidden builds a goa.ServiceError from an error.
func MakeForbidden(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "forbidden",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeNotFound builds a goa.ServiceError from an error.
func MakeNotFound(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "not-found",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// MakeBadRequest builds a goa.ServiceError from an error.
func MakeBadRequest(err error) *goa.ServiceError {
	return &goa.ServiceError{
		Name:    "bad-request",
		ID:      goa.NewErrorID(),
		Message: err.Error(),
	}
}

// NewModerationRequests initializes result type ModerationRequests from viewed
// result type ModerationRequests.
func NewModerationRequests(vres *moderationviews.ModerationRequests) *ModerationRequests {
	return newModerationRequests(vres.Projected)
}

// NewViewedModerationRequests initializes viewed result type
// ModerationRequests from result type ModerationRequests using the given view.
func NewViewedModerationRequests(res *ModerationRequests, view string) *moderationviews.ModerationRequests {
	p := newModerationRequestsView(res)
	return &moderationviews.ModerationRequests{Projected: p, View: "default"}
}

// newModerationRequests converts projected type ModerationRequests to service
// type ModerationRequests.
func newModerationRequests(vres *moderationviews.ModerationRequestsView) *ModerationRequests {
	res := &ModerationRequests{}
	if vres.TotalPages != nil {
		res.TotalPages = *vres.TotalPages
	}
	if vres.Requests != nil {
		res.Requests = make([]*ModerationRequest, len(vres.Requests))
		for i, val := range vres.Requests {
			res.Requests[i] = transformModerationviewsModerationRequestViewToModerationRequest(val)
		}
	}
	return res
}

// newModerationRequestsView projects result type ModerationRequests to
// projected type ModerationRequestsView using the "default" view.
func newModerationRequestsView(res *ModerationRequests) *moderationviews.ModerationRequestsView {
	vres := &moderationviews.ModerationRequestsView{
		TotalPages: &res.TotalPages,
	}
	if res.Requests != nil {
		vres.Requests = make([]*moderationviews.ModerationRequestView, len(res.Requests))
		for i, val := range res.Requests {
			vres.Requests[i] = transformModerationRequestToModerationviewsModerationRequestView(val)
		}
	}
	return vres
}

// transformModerationviewsModerationRequestViewToModerationRequest builds a
// value of type *ModerationRequest from a value of type
// *moderationviews.ModerationRequestView.
func transformModerationviewsModerationRequestViewToModerationRequest(v *moderationviews.ModerationRequestView) *ModerationRequest {
	if v == nil {
		return nil
	}
	res := &ModerationRequest{
		ID:             *v.ID,
		PostID:         *v.PostID,
		PostType:       *v.PostType,
		ReportedBy:     *v.ReportedBy,
		ReportedByName: v.ReportedByName,
		ReportedAt:     *v.ReportedAt,
		AcknowledgedBy: v.AcknowledgedBy,
		AcknowledgedAt: v.AcknowledgedAt,
	}
	if v.AcknowledgedByUser != nil {
		res.AcknowledgedByUser = transformModerationviewsUserInfoViewToUserInfo(v.AcknowledgedByUser)
	}

	return res
}

// transformModerationviewsUserInfoViewToUserInfo builds a value of type
// *UserInfo from a value of type *moderationviews.UserInfoView.
func transformModerationviewsUserInfoViewToUserInfo(v *moderationviews.UserInfoView) *UserInfo {
	if v == nil {
		return nil
	}
	res := &UserInfo{
		Name: *v.Name,
	}

	return res
}

// transformModerationRequestToModerationviewsModerationRequestView builds a
// value of type *moderationviews.ModerationRequestView from a value of type
// *ModerationRequest.
func transformModerationRequestToModerationviewsModerationRequestView(v *ModerationRequest) *moderationviews.ModerationRequestView {
	res := &moderationviews.ModerationRequestView{
		ID:             &v.ID,
		PostID:         &v.PostID,
		PostType:       &v.PostType,
		ReportedBy:     &v.ReportedBy,
		ReportedByName: v.ReportedByName,
		ReportedAt:     &v.ReportedAt,
		AcknowledgedBy: v.AcknowledgedBy,
		AcknowledgedAt: v.AcknowledgedAt,
	}
	if v.AcknowledgedByUser != nil {
		res.AcknowledgedByUser = transformUserInfoToModerationviewsUserInfoView(v.AcknowledgedByUser)
	}

	return res
}

// transformUserInfoToModerationviewsUserInfoView builds a value of type
// *moderationviews.UserInfoView from a value of type *UserInfo.
func transformUserInfoToModerationviewsUserInfoView(v *UserInfo) *moderationviews.UserInfoView {
	if v == nil {
		return nil
	}
	res := &moderationviews.UserInfoView{
		Name: &v.Name,
	}

	return res
}
