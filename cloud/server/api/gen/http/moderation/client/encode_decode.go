// Code generated by goa v3.2.4, DO NOT EDIT.
//
// moderation HTTP client encoders and decoders
//
// Command:
// $ goa gen gitlab.com/fieldkit/cloud/server/api/design

package client

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	moderation "gitlab.com/fieldkit/cloud/server/api/gen/moderation"
	moderationviews "gitlab.com/fieldkit/cloud/server/api/gen/moderation/views"
	goahttp "goa.design/goa/v3/http"
)

// BuildAddRequest instantiates a HTTP request object with method and path set
// to call the "moderation" service "add" endpoint
func (c *Client) BuildAddRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: AddModerationPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("moderation", "add", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeAddRequest returns an encoder for requests sent to the moderation add
// server.
func EncodeAddRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*moderation.ModerationAddPayload)
		if !ok {
			return goahttp.ErrInvalidType("moderation", "add", "*moderation.ModerationAddPayload", v)
		}
		if p.Auth != nil {
			head := *p.Auth
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		body := NewAddRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("moderation", "add", err)
		}
		return nil
	}
}

// DecodeAddResponse returns a decoder for responses returned by the moderation
// add endpoint. restoreBody controls whether the response body should be
// restored after having been read.
// DecodeAddResponse may return the following errors:
//   - "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//   - "forbidden" (type *goa.ServiceError): http.StatusForbidden
//   - "not-found" (type *goa.ServiceError): http.StatusNotFound
//   - "bad-request" (type *goa.ServiceError): http.StatusBadRequest
//   - error: internal error
func DecodeAddResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body AddResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "add", err)
			}
			err = ValidateAddResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "add", err)
			}
			res := NewAddModerationRequestOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body AddUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "add", err)
			}
			err = ValidateAddUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "add", err)
			}
			return nil, NewAddUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body AddForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "add", err)
			}
			err = ValidateAddForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "add", err)
			}
			return nil, NewAddForbidden(&body)
		case http.StatusNotFound:
			var (
				body AddNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "add", err)
			}
			err = ValidateAddNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "add", err)
			}
			return nil, NewAddNotFound(&body)
		case http.StatusBadRequest:
			var (
				body AddBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "add", err)
			}
			err = ValidateAddBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "add", err)
			}
			return nil, NewAddBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("moderation", "add", resp.StatusCode, string(body))
		}
	}
}

// BuildCancelRequest instantiates a HTTP request object with method and path
// set to call the "moderation" service "cancel" endpoint
func (c *Client) BuildCancelRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CancelModerationPath()}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("moderation", "cancel", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCancelRequest returns an encoder for requests sent to the moderation
// cancel server.
func EncodeCancelRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*moderation.CancelPayload)
		if !ok {
			return goahttp.ErrInvalidType("moderation", "cancel", "*moderation.CancelPayload", v)
		}
		{
			head := p.Auth
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		values.Add("postId", fmt.Sprintf("%v", p.PostID))
		values.Add("postType", p.PostType)
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeCancelResponse returns a decoder for responses returned by the
// moderation cancel endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeCancelResponse may return the following errors:
//   - "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//   - "forbidden" (type *goa.ServiceError): http.StatusForbidden
//   - "not-found" (type *goa.ServiceError): http.StatusNotFound
//   - "bad-request" (type *goa.ServiceError): http.StatusBadRequest
//   - error: internal error
func DecodeCancelResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			return nil, nil
		case http.StatusUnauthorized:
			var (
				body CancelUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "cancel", err)
			}
			err = ValidateCancelUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "cancel", err)
			}
			return nil, NewCancelUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body CancelForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "cancel", err)
			}
			err = ValidateCancelForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "cancel", err)
			}
			return nil, NewCancelForbidden(&body)
		case http.StatusNotFound:
			var (
				body CancelNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "cancel", err)
			}
			err = ValidateCancelNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "cancel", err)
			}
			return nil, NewCancelNotFound(&body)
		case http.StatusBadRequest:
			var (
				body CancelBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "cancel", err)
			}
			err = ValidateCancelBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "cancel", err)
			}
			return nil, NewCancelBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("moderation", "cancel", resp.StatusCode, string(body))
		}
	}
}

// BuildCheckUserReportRequest instantiates a HTTP request object with method
// and path set to call the "moderation" service "checkUserReport" endpoint
func (c *Client) BuildCheckUserReportRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CheckUserReportModerationPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("moderation", "checkUserReport", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCheckUserReportRequest returns an encoder for requests sent to the
// moderation checkUserReport server.
func EncodeCheckUserReportRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*moderation.CheckUserReportPayload)
		if !ok {
			return goahttp.ErrInvalidType("moderation", "checkUserReport", "*moderation.CheckUserReportPayload", v)
		}
		{
			head := p.Auth
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		values.Add("postId", fmt.Sprintf("%v", p.PostID))
		values.Add("postType", p.PostType)
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeCheckUserReportResponse returns a decoder for responses returned by
// the moderation checkUserReport endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeCheckUserReportResponse may return the following errors:
//   - "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//   - "forbidden" (type *goa.ServiceError): http.StatusForbidden
//   - "not-found" (type *goa.ServiceError): http.StatusNotFound
//   - "bad-request" (type *goa.ServiceError): http.StatusBadRequest
//   - error: internal error
func DecodeCheckUserReportResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body CheckUserReportOKResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "checkUserReport", err)
			}
			err = ValidateCheckUserReportOKResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "checkUserReport", err)
			}
			res := NewCheckUserReportResultOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body CheckUserReportUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "checkUserReport", err)
			}
			err = ValidateCheckUserReportUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "checkUserReport", err)
			}
			return nil, NewCheckUserReportUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body CheckUserReportForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "checkUserReport", err)
			}
			err = ValidateCheckUserReportForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "checkUserReport", err)
			}
			return nil, NewCheckUserReportForbidden(&body)
		case http.StatusNotFound:
			var (
				body CheckUserReportNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "checkUserReport", err)
			}
			err = ValidateCheckUserReportNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "checkUserReport", err)
			}
			return nil, NewCheckUserReportNotFound(&body)
		case http.StatusBadRequest:
			var (
				body CheckUserReportBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "checkUserReport", err)
			}
			err = ValidateCheckUserReportBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "checkUserReport", err)
			}
			return nil, NewCheckUserReportBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("moderation", "checkUserReport", resp.StatusCode, string(body))
		}
	}
}

// BuildAcknowledgeRequest instantiates a HTTP request object with method and
// path set to call the "moderation" service "acknowledge" endpoint
func (c *Client) BuildAcknowledgeRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		id int32
	)
	{
		p, ok := v.(*moderation.AcknowledgePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("moderation", "acknowledge", "*moderation.AcknowledgePayload", v)
		}
		id = p.ID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: AcknowledgeModerationPath(id)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("moderation", "acknowledge", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeAcknowledgeRequest returns an encoder for requests sent to the
// moderation acknowledge server.
func EncodeAcknowledgeRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*moderation.AcknowledgePayload)
		if !ok {
			return goahttp.ErrInvalidType("moderation", "acknowledge", "*moderation.AcknowledgePayload", v)
		}
		{
			head := p.Auth
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		values.Add("action", p.Action)
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeAcknowledgeResponse returns a decoder for responses returned by the
// moderation acknowledge endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeAcknowledgeResponse may return the following errors:
//   - "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//   - "forbidden" (type *goa.ServiceError): http.StatusForbidden
//   - "not-found" (type *goa.ServiceError): http.StatusNotFound
//   - "bad-request" (type *goa.ServiceError): http.StatusBadRequest
//   - error: internal error
func DecodeAcknowledgeResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body AcknowledgeOKResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "acknowledge", err)
			}
			err = ValidateAcknowledgeOKResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "acknowledge", err)
			}
			res := NewAcknowledgeModerationRequestOK(&body)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body AcknowledgeUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "acknowledge", err)
			}
			err = ValidateAcknowledgeUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "acknowledge", err)
			}
			return nil, NewAcknowledgeUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body AcknowledgeForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "acknowledge", err)
			}
			err = ValidateAcknowledgeForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "acknowledge", err)
			}
			return nil, NewAcknowledgeForbidden(&body)
		case http.StatusNotFound:
			var (
				body AcknowledgeNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "acknowledge", err)
			}
			err = ValidateAcknowledgeNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "acknowledge", err)
			}
			return nil, NewAcknowledgeNotFound(&body)
		case http.StatusBadRequest:
			var (
				body AcknowledgeBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "acknowledge", err)
			}
			err = ValidateAcknowledgeBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "acknowledge", err)
			}
			return nil, NewAcknowledgeBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("moderation", "acknowledge", resp.StatusCode, string(body))
		}
	}
}

// BuildListRequestsRequest instantiates a HTTP request object with method and
// path set to call the "moderation" service "listRequests" endpoint
func (c *Client) BuildListRequestsRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListRequestsModerationPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("moderation", "listRequests", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListRequestsRequest returns an encoder for requests sent to the
// moderation listRequests server.
func EncodeListRequestsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*moderation.ListRequestsPayload)
		if !ok {
			return goahttp.ErrInvalidType("moderation", "listRequests", "*moderation.ListRequestsPayload", v)
		}
		{
			head := p.Auth
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		values.Add("page", fmt.Sprintf("%v", p.Page))
		values.Add("pageSize", fmt.Sprintf("%v", p.PageSize))
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeListRequestsResponse returns a decoder for responses returned by the
// moderation listRequests endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeListRequestsResponse may return the following errors:
//   - "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//   - "forbidden" (type *goa.ServiceError): http.StatusForbidden
//   - "not-found" (type *goa.ServiceError): http.StatusNotFound
//   - "bad-request" (type *goa.ServiceError): http.StatusBadRequest
//   - error: internal error
func DecodeListRequestsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListRequestsOKResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "listRequests", err)
			}
			p := NewListRequestsModerationRequestsOK(&body)
			view := "default"
			vres := &moderationviews.ModerationRequests{Projected: p, View: view}
			if err = moderationviews.ValidateModerationRequests(vres); err != nil {
				return nil, goahttp.ErrValidationError("moderation", "listRequests", err)
			}
			res := moderation.NewModerationRequests(vres)
			return res, nil
		case http.StatusUnauthorized:
			var (
				body ListRequestsUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "listRequests", err)
			}
			err = ValidateListRequestsUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "listRequests", err)
			}
			return nil, NewListRequestsUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body ListRequestsForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "listRequests", err)
			}
			err = ValidateListRequestsForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "listRequests", err)
			}
			return nil, NewListRequestsForbidden(&body)
		case http.StatusNotFound:
			var (
				body ListRequestsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "listRequests", err)
			}
			err = ValidateListRequestsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "listRequests", err)
			}
			return nil, NewListRequestsNotFound(&body)
		case http.StatusBadRequest:
			var (
				body ListRequestsBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "listRequests", err)
			}
			err = ValidateListRequestsBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "listRequests", err)
			}
			return nil, NewListRequestsBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("moderation", "listRequests", resp.StatusCode, string(body))
		}
	}
}

// BuildGetContentRequest instantiates a HTTP request object with method and
// path set to call the "moderation" service "getContent" endpoint
func (c *Client) BuildGetContentRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		postType string
		postID   int32
	)
	{
		p, ok := v.(*moderation.GetContentPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("moderation", "getContent", "*moderation.GetContentPayload", v)
		}
		postType = p.PostType
		postID = p.PostID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetContentModerationPath(postType, postID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("moderation", "getContent", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetContentRequest returns an encoder for requests sent to the
// moderation getContent server.
func EncodeGetContentRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*moderation.GetContentPayload)
		if !ok {
			return goahttp.ErrInvalidType("moderation", "getContent", "*moderation.GetContentPayload", v)
		}
		{
			head := p.Auth
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		return nil
	}
}

// DecodeGetContentResponse returns a decoder for responses returned by the
// moderation getContent endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeGetContentResponse may return the following errors:
//   - "unauthorized" (type *goa.ServiceError): http.StatusUnauthorized
//   - "forbidden" (type *goa.ServiceError): http.StatusForbidden
//   - "not-found" (type *goa.ServiceError): http.StatusNotFound
//   - "bad-request" (type *goa.ServiceError): http.StatusBadRequest
//   - error: internal error
func DecodeGetContentResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "getContent", err)
			}
			return body, nil
		case http.StatusUnauthorized:
			var (
				body GetContentUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "getContent", err)
			}
			err = ValidateGetContentUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "getContent", err)
			}
			return nil, NewGetContentUnauthorized(&body)
		case http.StatusForbidden:
			var (
				body GetContentForbiddenResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "getContent", err)
			}
			err = ValidateGetContentForbiddenResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "getContent", err)
			}
			return nil, NewGetContentForbidden(&body)
		case http.StatusNotFound:
			var (
				body GetContentNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "getContent", err)
			}
			err = ValidateGetContentNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "getContent", err)
			}
			return nil, NewGetContentNotFound(&body)
		case http.StatusBadRequest:
			var (
				body GetContentBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("moderation", "getContent", err)
			}
			err = ValidateGetContentBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("moderation", "getContent", err)
			}
			return nil, NewGetContentBadRequest(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("moderation", "getContent", resp.StatusCode, string(body))
		}
	}
}

// unmarshalUserInfoResponseBodyToModerationUserInfo builds a value of type
// *moderation.UserInfo from a value of type *UserInfoResponseBody.
func unmarshalUserInfoResponseBodyToModerationUserInfo(v *UserInfoResponseBody) *moderation.UserInfo {
	if v == nil {
		return nil
	}
	res := &moderation.UserInfo{
		Name: *v.Name,
	}

	return res
}

// unmarshalModerationRequestResponseBodyToModerationviewsModerationRequestView
// builds a value of type *moderationviews.ModerationRequestView from a value
// of type *ModerationRequestResponseBody.
func unmarshalModerationRequestResponseBodyToModerationviewsModerationRequestView(v *ModerationRequestResponseBody) *moderationviews.ModerationRequestView {
	res := &moderationviews.ModerationRequestView{
		ID:             v.ID,
		PostID:         v.PostID,
		PostType:       v.PostType,
		ReportedBy:     v.ReportedBy,
		ReportedByName: v.ReportedByName,
		ReportedAt:     v.ReportedAt,
		AcknowledgedBy: v.AcknowledgedBy,
		AcknowledgedAt: v.AcknowledgedAt,
	}
	if v.AcknowledgedByUser != nil {
		res.AcknowledgedByUser = unmarshalUserInfoResponseBodyToModerationviewsUserInfoView(v.AcknowledgedByUser)
	}

	return res
}

// unmarshalUserInfoResponseBodyToModerationviewsUserInfoView builds a value of
// type *moderationviews.UserInfoView from a value of type
// *UserInfoResponseBody.
func unmarshalUserInfoResponseBodyToModerationviewsUserInfoView(v *UserInfoResponseBody) *moderationviews.UserInfoView {
	if v == nil {
		return nil
	}
	res := &moderationviews.UserInfoView{
		Name: v.Name,
	}

	return res
}
