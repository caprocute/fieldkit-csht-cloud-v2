use anyhow::Result;
use chrono::Utc;
use clap::Parser;
use regex::*;
use serde::{Deserialize, Serialize};
use std::{
    collections::HashSet,
    fs::File,
    io::{Read, Write},
    sync::atomic::AtomicUsize,
};
use walkdir::WalkDir;

#[derive(Debug, Clone, PartialEq)]
pub struct StringId {
    name: String,
    id: usize,
}

impl StringId {
    pub fn new(name: String, id: usize) -> Self {
        Self { name, id }
    }
}

#[derive(Serialize, Deserialize, Debug, Default, Clone)]
pub struct StringFile {
    strings: Vec<LocalizedString>,
}

impl StringFile {
    pub fn from_path(path: &str) -> Result<Self> {
        if let Ok(_) = std::fs::metadata(path) {
            let json_file = File::options().read(true).open(path)?;
            Ok(serde_json::from_reader(json_file)?)
        } else {
            Ok(StringFile::default())
        }
    }

    fn add_or_update_default(&mut self, id: &&StringId, defaults: &LoadedStrings) {
        let default = defaults
            .strings
            .get(&id.name)
            .map(|l| l.value.clone())
            .flatten();

        for s in self.strings.iter_mut() {
            if s.name == id.name {
                s.english = default;
                return;
            }
        }

        self.strings.push(LocalizedString {
            name: id.name.clone(),
            english: default,
            value: None,
        });
    }

    pub fn get(&self, key: &str) -> Option<&LocalizedString> {
        for row in self.strings.iter() {
            if row.name == key {
                return Some(row);
            }
        }
        None
    }

    fn write_table(&self, table_file: &str, identifier: &str, order: &StringIds) -> Result<()> {
        let mut file = File::options()
            .write(true)
            .create(true)
            .truncate(true)
            .open(table_file)?;

        file.write_fmt(format_args!(
            "// This file was generated by strfirm on {}\n\n",
            Utc::now()
        ))?;
        file.write_fmt(format_args!("#include \"l10n.h\"\n\n"))?;
        file.write_fmt(format_args!("const char* const {}[] = {{\n", identifier))?;
        for string_id in order.0.iter() {
            file.write_fmt(format_args!(
                "  \"{}\", // {} \n",
                self.get(&string_id.name)
                    .map(|s| s.value.as_ref())
                    .flatten()
                    .map(|s| s.as_str())
                    .unwrap_or("MISSING"),
                string_id.name
            ))?;
        }
        file.write_fmt(format_args!("}};\n"))?;

        Ok(())
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct LocalizedString {
    name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    english: Option<String>,
    value: Option<String>,
}

#[derive(Debug)]
pub struct StringIds(Vec<StringId>);

impl StringIds {
    pub fn from_files(path: String) -> Result<StringIds> {
        let mut keys = HashSet::new();

        for entry in WalkDir::new(path) {
            let entry = entry?;
            let path = entry.path();

            match path.extension().map(|e| e.to_str()).flatten() {
                Some("c") | Some("cpp") | Some("h") => {
                    let mut file = File::open(&path)?;
                    let mut data = String::new();
                    file.read_to_string(&mut data)?;
                    keys.extend(Self::find_keys(&data));
                }
                _ => {}
            }
        }

        Self::from_keys(keys)
    }

    pub fn find_keys(line: &str) -> Vec<String> {
        let menu_option_re = Regex::new(r"(FK_MENU_([A-Z0-9_]+))").unwrap();

        menu_option_re
            .captures_iter(&line)
            .map(|captures| captures.get(1))
            .flatten()
            .map(|capture| capture.as_str().to_owned())
            .collect()
    }

    pub fn from_keys(keys: HashSet<String>) -> Result<StringIds> {
        let ids = AtomicUsize::new(0);

        use itertools::*;

        Ok(StringIds(
            keys.into_iter()
                .sorted()
                .map(|name| {
                    StringId::new(
                        name.as_str().to_owned(),
                        ids.fetch_add(1, std::sync::atomic::Ordering::SeqCst),
                    )
                })
                .collect(),
        ))
    }

    pub fn from_stdin() -> Result<StringIds> {
        let lines: Vec<String> = std::io::stdin()
            .lines()
            .collect::<Result<Vec<_>, std::io::Error>>()?;

        Self::from_lines(lines)
    }

    pub fn from_lines(lines: Vec<String>) -> Result<StringIds> {
        let keys: HashSet<String> = lines
            .into_iter()
            .flat_map(|line| Self::find_keys(&line))
            .collect();

        Self::from_keys(keys)
    }
}

pub fn write_header(ids: &StringIds, locales: &Vec<LocaleInfo>) -> Result<()> {
    let mut header = File::options()
        .write(true)
        .create(true)
        .truncate(true)
        .open("l10n.h")?;

    header.write_fmt(format_args!(
        "// This file was generated by strfirm on {}\n\n",
        Utc::now()
    ))?;
    header.write_fmt(format_args!("#pragma once\n\n"))?;
    for locale in locales.iter() {
        header.write_fmt(format_args!(
            "extern const char* const {}[];\n",
            locale.table_identifier
        ))?;
    }
    header.write_fmt(format_args!("\n"))?;
    for string_id in ids.0.iter() {
        header.write_fmt(format_args!(
            "#define {:64} ((uint32_t){})\n",
            &string_id.name, string_id.id
        ))?;
    }

    Ok(())
}

#[derive(Debug, Clone)]
pub struct LocaleInfo {
    name: &'static str,
    table_identifier: &'static str,
}

impl LocaleInfo {
    fn is_english(&self) -> bool {
        self.name == EN_US
    }

    fn json_filename(&self) -> String {
        format!("{}.json", self.name)
    }
}

#[derive(Debug, Clone)]
pub struct LoadedStrings {
    locale: LocaleInfo,
    strings: StringFile,
}

const EN_US: &str = "en-US";
const ES_LA: &str = "es-LA";

#[derive(Parser)]
struct Cli {
    #[arg(long, short)]
    path: Option<String>,
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    let ids = match cli.path {
        Some(path) => StringIds::from_files(path)?,
        None => StringIds::from_stdin()?,
    };

    let locales = vec![
        LocaleInfo {
            name: EN_US,
            table_identifier: "en_US",
        },
        LocaleInfo {
            name: ES_LA,
            table_identifier: "es_LA",
        },
    ];

    let mut loaded = locales
        .clone()
        .into_iter()
        .map(|locale| {
            Ok(LoadedStrings {
                strings: StringFile::from_path(&locale.json_filename())?,
                locale,
            })
        })
        .collect::<Result<Vec<_>>>()?;

    let english = loaded
        .iter()
        .find(|l| l.locale.is_english())
        .expect("No english locale?")
        .clone();

    write_header(&ids, &locales)?;

    for loaded in loaded.iter_mut() {
        for id in ids.0.iter() {
            loaded.strings.add_or_update_default(&id, &english);
        }

        let json_file = File::options()
            .create(true)
            .truncate(true)
            .write(true)
            .open(loaded.locale.json_filename())?;
        serde_json::to_writer_pretty(json_file, &loaded.strings)?;

        let table_file = format!("{}.c", loaded.locale.name);
        let table_identifier = loaded.locale.table_identifier;
        loaded
            .strings
            .write_table(&table_file, table_identifier, &ids)?;
    }

    Ok(())
}
